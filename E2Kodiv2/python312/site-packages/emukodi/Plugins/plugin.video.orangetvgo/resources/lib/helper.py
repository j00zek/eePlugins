import e2kodi__init__ # aby zainicjowac sciezki i nie musiec zmieniac czegos w kodzie

import json

import sys, io, os
import calendar
from datetime import datetime, timedelta
import time
import collections

import resources.lib.iso8601
import requests
from urllib.parse import quote, unquote, quote_plus

import xbmc
import xbmcgui
import xbmcvfs
import xbmcaddon
import xbmcplugin

import hmac,random,math,base64

from resources.lib.brotlipython import brotlidec
import re


def resp_text(resp):
    """Return decoded response text."""
    if resp and resp.headers.get('content-encoding') == 'br':
        out = []
        # terrible implementation but it's pure Python
        return brotlidec(resp.content, out).decode('utf-8')
    response_content = resp.text

    return response_content.replace("\'",'"')

class Helper:
    def __init__(self, base_url=None, handle=None):
        self.base_url = base_url
        self.handle = handle
        self.addon = xbmcaddon.Addon(id='plugin.video.orangetvgo')
        self.addon_name = self.addon.getAddonInfo('id')
        self.addon_version = self.addon.getAddonInfo('version')
        self.datapath = self.translate_path(self.get_path('profile'))
        
        self.art = {'icon': self.addon.getAddonInfo('icon'),
                    'fanart': self.addon.getAddonInfo('fanart'),
                }
        
        
        
        self.proxyport = self.get_setting('proxyport')

        try:
            self.kukis = self.load_file(self.datapath+'kukis', isJSON=True)
        except:
            self.kukis = {}
            
        self._sess = None
        self.kuk = {}

        # API
        self.params = {}
        self.currentProfileId = self.get_setting('currentProfileId') 
        self.householdExtId = self.get_setting('householdExtId') 

        self.UA ='Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:129.0) Gecko/20100101 Firefox/129.0'
        self.host = 'tvgo.orange.pl'
        self.OtvDeviceInfo = '[web_otf]/[3.3.6/5539]/{}'.format(self.UA)
        self.OtvDeviceInfo2= 'dev_type=web_otf&app_version=1.10.0&web_native='+quote_plus(self.UA)+'&hh_tech='+self.get_setting('hh_tech')#ftth
        self.main_url =  'https://tvgo.orange.pl' 
        self.api_url = self.main_url+'/gpapi/{}'
        

        self.chan_url = 'https://tvgo.orange.pl/gpapi/live/channel/{}?deviceCat=otg'
        
        self.chan_session_url = 'https://tvgo.orange.pl/gpapi/live/channel/{}/session'
        
        
        
        self.headers = {
            'Host': self.host,
            'User-Agent': self.UA,
            'Accept-Language': 'pl,en-US;q=0.7,en;q=0.3',
            #'Content-Type': 'application/vnd.orangeott.v1+json',
            #'OtvDeviceInfo': self.OtvDeviceInfo,
            'OtvDeviceInfo2': self.OtvDeviceInfo2,
            'X-Country-Code': 'pl',
            'Origin': 'https://tvgo.orange.pl'}    

        
        self.subscrlogin = 'https://tvgo.orange.pl/gpapi2/auth/login?deviceCat=otg'#self.api_url.format('user/login')+'?deviceCat=otg'

        self.login = self.get_setting('login')
        self.password = self.get_setting('password')
        
        self.profile_url='https://tvgo.orange.pl/gpapi/user/login/profile'

    @property
    def sess(self):
        if self._sess is None:
            self._sess = requests.Session()
            if self.kukis:
                self._sess.cookies.update(self.kukis)
                
                self._sess.cookies.update(self.kuk)
        return self._sess    

    def input_dialog(self, text, typ=None):
        typ = xbmcgui.INPUT_ALPHANUM if not typ else typ
        return xbmcgui.Dialog().input(text, type=typ)
        
    def get_path(self ,data):    
        return self.addon.getAddonInfo(data)
        
    def translate_path(self ,data):
        try:
            return xbmcvfs.translatePath(data)
        except:
            return xbmc.translatePath(data).decode('utf-8')
            
    def save_file(self, file, data, isJSON=False):
        with io.open(file, 'w', encoding="utf-8") as f:
            if isJSON == True:
                str_ = json.dumps(data,indent=4, sort_keys=True,separators=(',', ': '), ensure_ascii=False)
                f.write(str(str_))
            else:
                f.write(data)

    def load_file(self, file, isJSON=False):

        if not os.path.isfile(file):
            return None
    
        with io.open(file, 'r', encoding='utf-8') as f:
            if isJSON == True:
                return json.load(f, object_pairs_hook=collections.OrderedDict)
            else:
                return f.read() 

        
    def get_setting(self, setting_id):
        setting = xbmcaddon.Addon(self.addon_name).getSetting(setting_id)
        if setting == 'true':
            return True
        elif setting == 'false':
            return False
        else:
            return setting
    
    def set_setting(self, key, value):
        return xbmcaddon.Addon(self.addon_name).setSetting(key, value)
        
        
    def open_settings(self):
        xbmcaddon.Addon(self.addon_name).openSettings()

    def sleep(self, time):
        return xbmc.sleep(int(time))
    
    def dialog_select(self, heading, label):
        return xbmcgui.Dialog().select(heading,label)
        
    def dialog_multiselect(self, heading, label):
        return xbmcgui.Dialog().dialog_multiselect(heading,label)
        
    def dialog_choice(self, heading, message, agree, disagree):
        return xbmcgui.Dialog().yesno(heading, message, yeslabel=agree, nolabel=disagree)
        
        
    def add_item(self, title, url, playable=False, info=None, art=None, content=None, folder=True, contextmenu = None):

        list_item = xbmcgui.ListItem(label=title)
        if playable:
            list_item.setProperty('IsPlayable', 'true')
            folder = False
        if art:
            list_item.setArt(art)
        else:
            art = {
                'icon': self.addon.getAddonInfo('icon'),
                'fanart': self.addon.getAddonInfo('fanart')
            }
            list_item.setArt(art)
        if info:
            list_item.setInfo('Video', info)
        if content:
            xbmcplugin.setContent(self.handle, content)
        if contextmenu:
            list_item.addContextMenuItems(contextmenu, replaceItems=True)
        xbmcplugin.addSortMethod(self.handle, sortMethod=xbmcplugin.SORT_METHOD_NONE, label2Mask = "%R, %Y, %P")    
        xbmcplugin.addDirectoryItem(self.handle, url, list_item, isFolder=folder)

    def eod(self, cache=True):
        xbmcplugin.endOfDirectory(self.handle, cacheToDisc=cache)

    def refresh(self):
        return xbmc.executebuiltin('Container.Refresh()')
        
    def update(self,func=''):
        return xbmc.executebuiltin('Container.Refresh(%s)'%func)
        
    def updatex(self,func=''):
        return xbmc.executebuiltin('Container.Update(%s)'%func)

    def update(self,func=''):
        return xbmc.executebuiltin('Container.Refresh(%s)'%func)
        
    def runplugin(self,func=''):
        return xbmc.executebuiltin('RunPlugin(%s))'%func)
        
    def notification(self, heading, message):
        xbmcgui.Dialog().notification(heading, message, time=3000)
        
    def setContent(self,content):
        xbmcplugin.setContent(self.handle, content)
        
    def request_sess(self, url, method='get', data={}, headers={}, cookies={}, params = {}, result=True, json=False, allow=True , json_data = False):
        params = params if params else self.params
        if  self.get_setting('ci')=='' or  self.get_setting('ca')=='':
            ci,ca=self.getC()
            self.set_setting('ci',ci)
            self.set_setting('ca',ca)
        cookies.update({
            'AnalyticsData':self.addon.getSetting('ca'),
            'I12':self.addon.getSetting('ci')
        })
        
        if method == 'get':
            resp = self.sess.get(url, headers=headers, cookies=cookies, timeout=30, params = params, allow_redirects=allow)
        elif method == 'post':
            if json_data:
                resp = self.sess.post(url, headers=headers, json=data, cookies=cookies, timeout=30, params = params, allow_redirects=allow)
            else:
                resp = self.sess.post(url, headers=headers, data=data, cookies=cookies, timeout=30, params = params, allow_redirects=allow)
        elif method == 'delete':
            resp = self.sess.delete(url, headers=headers, cookies=cookies, timeout=30, params = params, allow_redirects=allow)

        if result:
            return resp.json() if json else resp_text(resp)
        else:
            return resp
            
    def cookies_string(self, kukiz):
        return ''.join(['%s=%s;'%(cn, quote(cv)) for (cn,cv) in (kukiz).items()]) 
        
    def PlayVid (self, mpdurl, lic_url='', PROTOCOL='', DRM='', certificate = '', flags=True, subs = None):
        from inputstreamhelper import Helper
        play_item = xbmcgui.ListItem(path=mpdurl)
        if subs:
            play_item.setSubtitles(subs)
        if PROTOCOL:

            is_helper = Helper(PROTOCOL, drm=DRM)
            if is_helper.check_inputstream():
                if sys.version_info >= (3,0,0):
                    play_item.setProperty('inputstream', is_helper.inputstream_addon)
                else:
                    play_item.setProperty('inputstreamaddon', is_helper.inputstream_addon)
                if 'mpd' in PROTOCOL:
                    play_item.setMimeType('application/xml+dash')
                else:
                    play_item.setMimeType('application/vnd.apple.mpegurl')
                play_item.setProperty('inputstream.adaptive.manifest_type', PROTOCOL)
                play_item.setProperty('inputstream.adaptive.stream_headers', 'User-Agent='+self.UA+'&Referer=https://tvgo.orange.pl/&Origin=https://tvgo.orange.pl')
                play_item.setProperty('inputstream.adaptive.manifest_headers', 'User-Agent='+self.UA+'&Referer=https://tvgo.orange.pl/&Origin=https://tvgo.orange.pl')
                if DRM and lic_url:
                    play_item.setProperty('inputstream.adaptive.license_type', DRM)
                    play_item.setProperty('inputstream.adaptive.manifest_update_parameter', 'full')
                    play_item.setProperty('inputstream.adaptive.license_key', lic_url)
                    if certificate:
                        play_item.setProperty('inputstream.adaptive.server_certificate', certificate)
                if flags:
                    play_item.setProperty('inputstream.adaptive.license_flags', "persistent_storage")
                play_item.setContentLookup(False)
        xbmcplugin.setResolvedUrl(self.handle, True, listitem=play_item)
        
    def formatTime(self, czas, format):
        try:
            formated = datetime.strptime(czas, format) 
        except TypeError:
            formated = datetime(*(time.strptime(czas, format)[0:6]))
        formatedx = (formated).strftime('%H:%M')
        return formatedx

    def getCorrectTime(self, czas):
        try:
            current_date_temp = datetime.strptime(czas, "%Y-%m-%dT%H:%M:%SZ") #'2022-04-16T12:30:00Z'
        except TypeError:
            current_date_temp = datetime(*(time.strptime(czas, "%Y-%m-%dT%H:%M:%SZ")[0:6]))
        datastart = (current_date_temp + timedelta(hours=+2)).strftime('%H:%M')
        return datastart
        
    def timeNow(self, sek=False):
        now=datetime.utcnow()+timedelta(hours=2)

        czas=now.strftime('%Y-%m-%d')

        try:
            format_date=datetime.strptime(czas, '%Y-%m-%d')
        except TypeError:
            format_date=datetime(*(time.strptime(czas, '%Y-%m-%d')[0:6]))    
        if sek:
                now=datetime.utcnow()
                czas=now.strftime('%Y-%m-%d %H:%M')
                
                try:
                    format_date=datetime.strptime(czas, '%Y-%m-%d %H:%M')
                except TypeError:
                    format_date=datetime(*(time.strptime(czas, '%Y-%m-%d %H:%M')[0:6]))
        return format_date
    
    def CreateDays(self):
        dzis=self.timeNow()
        timestampdzis = calendar.timegm(dzis.timetuple())
        tydzien = int(timestampdzis)-604800
        out=[]
        for i in range(int(timestampdzis),tydzien,-86400):
            x = datetime.utcfromtimestamp(i)
            dzien = (x.strftime('%d.%m'))
            dnitygodnia = ("poniedziałek","wtorek","środa","czwartek","piątek","sobota","niedziela")
            
            day = x.weekday()

            dzientyg = dnitygodnia[day]

            out.append({'dzien':dzientyg+ ' '+dzien,'tstamp':str(i)}) 
            
        return out     

    def string_to_date(self, string, string_format):
        s_tuple = tuple([int(x) for x in string[:10].split('-')]) + tuple([int(x) for x in string[11:].split(':')])
        s_to_datetime = datetime(*s_tuple).strftime(string_format)
        return s_to_datetime

    def parse_datetime(self, iso8601_string, localize=False):
        """Parse ISO8601 string to datetime object."""
        datetime_obj = iso8601.parse_date(iso8601_string)
        if localize:
            return self.utc_to_local(datetime_obj)
        else:
            return datetime_obj

    def to_timestamp(self, a_date):
        if a_date.tzinfo:
            epoch = datetime(1970, 1, 1, tzinfo=pytz.UTC)
            diff = a_date.astimezone(pytz.UTC) - epoch
        else:
            epoch = datetime(1970, 1, 1)
            diff = a_date - epoch
        return int(diff.total_seconds())*1000
    
    ###2024-02-17
    def hmac_md5(self,key,s):
        return hmac.new(key.encode('utf-8'), s.encode('utf-8'), 'MD5').hexdigest()

    def code_gen(self,x,digit=False):
        base='0123456789abcdef' if not digit else '0123456789'
        r=15 if not digit else 9
        code=''
        for i in range(0,x):
            code+=base[random.randint(0,r)]
        return code
        
    def extra_hea(self):
        e=self.code_gen(13,True)
        t=int(1000*time.time())
        n=int(math.floor(t/72e5)*72e5)
        r=e+'a41/1121_a{gm15;6'
        h=self.hmac_md5(str(n),r)
        b= base64.b64encode(bytes.fromhex(h)).decode()
        return {'I12':e,'Analyticsdata':'1.10.0_'+b}
        
    def getC(self):
        ci=''
        ca=''
        
        url='https://tvgo.orange.pl/'
        hea={
            'User-Agent':self.UA
        }
        resp=requests.get(url,headers=hea).text
        
        a_ci=re.compile('I12=([^;]+?);').findall(resp)
        ci='' if len(a_ci)==0 else a_ci[0]
        
        scripts=re.compile('<script>((?:(?!</script>).)*?)</script>').findall(resp)
        scr=[s for s in scripts if 'AnalyticsData' in s]
        
        if len(scr)>0:
            data=re.sub(r'document\[([^]]+?)\]','var result',scr[0])

            jsPayload = '''
            function x(){
            xxx
            return result
            }
            '''
            jsPayload=jsPayload.replace('xxx',data)
            if 0:
                import js2py
                x=js2py.eval_js(jsPayload)
                cont=x()      
            else: #ewaluacja dukiem
                dukRetFile = '/tmp/.emukodi/duk.ret'
                cmd = '/usr/bin/duk -e "function x(){' + data + '\nreturn result};print(x());" > ' + dukRetFile
                open("/tmp/jsPayload.txt", "w").write(cmd)
                os.system(cmd)
                cont = open(dukRetFile, 'r').read()
                
            a_ca=re.compile('AnalyticsData=([^;]+?);').findall(cont)
            ca='' if len(a_ca)==0 else a_ca[0]
    
        return ci,ca

    @staticmethod
    def utc_to_local(utc_dt):
        # get integer timestamp to avoid precision lost
        timestamp = calendar.timegm(utc_dt.timetuple())
        local_dt = datetime.fromtimestamp(timestamp)
        assert utc_dt.resolution >= timedelta(microseconds=1)
        return local_dt.replace(microsecond=utc_dt.microsecond)
